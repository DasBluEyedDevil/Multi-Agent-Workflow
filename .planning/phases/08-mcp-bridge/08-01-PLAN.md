---
phase: 08-mcp-bridge
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - mcp-bridge/lib/mcp-core.sh
  - mcp-bridge/lib/mcp-errors.sh
autonomous: true

must_haves:
  truths:
    - "MCP server can parse JSON-RPC 2.0 requests from stdin"
    - "MCP server can send properly formatted JSON-RPC responses to stdout"
    - "MCP server handles standard JSON-RPC error codes correctly"
  artifacts:
    - path: "mcp-bridge/lib/mcp-core.sh"
      provides: "JSON-RPC protocol handling (parse, route, respond)"
      exports: ["mcp_parse_request", "mcp_send_response", "mcp_send_error", "mcp_send_result"]
    - path: "mcp-bridge/lib/mcp-errors.sh"
      provides: "MCP error code definitions and error response builders"
      exports: ["mcp_error_parse", "mcp_error_invalid_request", "mcp_error_method_not_found", "mcp_error_invalid_params", "mcp_error_internal", "mcp_error_server"]
  key_links:
    - from: "mcp-core.sh"
      to: "mcp-errors.sh"
      via: "source/import"
      pattern: "source.*mcp-errors"
    - from: "stdin"
      to: "mcp_parse_request"
      via: "read line"
      pattern: "while IFS= read -r line"
    - from: "mcp_send_response"
      to: "stdout"
      via: "echo"
      pattern: "echo.*jsonrpc.*2.0"
---

<objective>
Implement the MCP protocol foundation: JSON-RPC 2.0 message parsing, routing, and response generation, plus standard error code handling.

Purpose: This is the communication layer that all MCP tools depend on. Without correct protocol handling, the server cannot communicate with MCP clients.
Output: Two library files providing protocol primitives used by the rest of the MCP server.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/08-mcp-bridge/08-CONTEXT.md
@.planning/phases/08-mcp-bridge/08-RESEARCH.md

# MCP Protocol Requirements (from RESEARCH.md):
# - JSON-RPC 2.0 over stdio with newline-delimited messages
# - Messages MUST NOT contain embedded newlines
# - Server writes UTF-8 to stderr for logging, stdout ONLY for MCP messages
# - Standard JSON-RPC error codes: -32700, -32600, -32601, -32602, -32603, -32000

# Key patterns from RESEARCH.md:
# - Use jq for all JSON parsing and generation (never string interpolation)
# - Always include request ID in responses
# - Use stderr for logging: echo "debug" >&2
</context>

<tasks>

<task type="auto">
  <name>Create mcp-errors.sh with standard error codes</name>
  <files>mcp-bridge/lib/mcp-errors.sh</files>
  <action>
Create mcp-bridge/lib/mcp-errors.sh with standard MCP/JSON-RPC error codes and response builders.

Required error codes (per JSON-RPC 2.0 spec):
- -32700: Parse error (invalid JSON)
- -32600: Invalid Request (not a valid JSON-RPC request)
- -32601: Method not found
- -32602: Invalid params
- -32603: Internal error
- -32000: Server error (implementation-defined)

Functions to implement:
1. mcp_error_parse(id, message, data?) - Returns JSON-RPC error response for parse errors
2. mcp_error_invalid_request(id, message, data?) - Invalid request error
3. mcp_error_method_not_found(id, method) - Method not found error
4. mcp_error_invalid_params(id, message) - Invalid parameters error
5. mcp_error_internal(id, message) - Internal server error
6. mcp_error_server(id, message, data?) - Generic server error

Each function MUST:
- Use jq for JSON generation (never shell string interpolation)
- Handle empty/null ID correctly (convert to null in JSON)
- Write to stdout (these are protocol responses, not logs)
- Include error code, message, and optional data field

Example structure from RESEARCH.md:
```bash
jq -n \
    --arg id "$id" \
    --argjson code "$code" \
    --arg message "$message" \
    '{
        jsonrpc: "2.0",
        id: (if $id == "" then null else $id end),
        error: {
            code: $code,
            message: $message,
            data: $data
        }
    }'
```

Add header comments documenting:
- File purpose
- Error code reference table
- Usage examples
  </action>
  <verify>bash -c 'source mcp-bridge/lib/mcp-errors.sh && mcp_error_parse "123" "test" | jq -e ".error.code == -32700"'</verify>
  <done>Error functions exist and return valid JSON-RPC error objects with correct error codes</done>
</task>

<task type="auto">
  <name>Create mcp-core.sh with protocol handling</name>
  <files>mcp-bridge/lib/mcp-core.sh</files>
  <action>
Create mcp-bridge/lib/mcp-core.sh with core MCP protocol handling functions.

This file MUST source mcp-errors.sh at the top.

Functions to implement:

1. mcp_parse_request(line)
   - Input: A single line from stdin (JSON-RPC request)
   - Output: Echo JSON object with extracted fields: id, method, params
   - Use jq to parse: echo "$line" | jq -r '{id: .id, method: .method, params: .params}'
   - Return empty if line is empty or not valid JSON

2. mcp_send_result(id, result_json)
   - Send a successful JSON-RPC response
   - Input: request ID and result (already JSON string)
   - Output: Properly formatted JSON-RPC 2.0 response to stdout
   - Use jq with --argjson for the result field

3. mcp_send_response(id, content_text, is_error)
   - Send a tool result response (wraps content in MCP ToolResult format)
   - Input: request ID, text content, boolean isError
   - Output: JSON-RPC response with result.content array
   - Format per MCP spec: {"content": [{"type": "text", "text": "..."}], "isError": false}

4. mcp_send_initialize_result(id, protocol_version)
   - Send InitializeResult for the initialize method
   - Include protocolVersion, capabilities (tools: {listChanged: false}), serverInfo
   - Server name: "kimi-mcp-server", version: "1.0.0"

5. mcp_send_tools_list(id, tools_json)
   - Send tools/list result
   - Input: request ID and tools array as JSON string
   - Wrap in {tools: [...]} structure

Critical requirements:
- ALL JSON output MUST use jq (no echo with string concatenation)
- ALL logging MUST go to stderr (>&2)
- Request ID must be preserved and returned exactly (except null -> null)
- Protocol version: "2025-11-25"

Add header with:
- File purpose
- Dependencies (mcp-errors.sh)
- Protocol version supported
  </action>
  <verify>bash -c 'source mcp-bridge/lib/mcp-core.sh && mcp_send_result "123" "\"test\"" | jq -e ".jsonrpc == \"2.0\" and .id == \"123\" and .result == \"test\""'</verify>
  <done>Core protocol functions exist, return valid JSON-RPC, and preserve request IDs correctly</done>
</task>

<task type="auto">
  <name>Create unit tests for protocol functions</name>
  <files>mcp-bridge/tests/test-mcp-core.bats</files>
  <action>
Create mcp-bridge/tests/test-mcp-core.bats with unit tests for protocol functions.

Test cases for mcp_parse_request:
- Valid JSON-RPC request with id, method, params
- Request with null id (notification)
- Request without params (should default to {})
- Invalid JSON (should handle gracefully)
- Empty line (should return empty)

Test cases for mcp_send_result:
- Valid result with string ID
- Valid result with numeric ID
- Valid result with null ID

Test cases for mcp_send_response:
- Success response (isError: false)
- Error response (isError: true)
- Response with special characters in text (quotes, newlines)

Test cases for error functions:
- Each error code returns correct value
- Error messages are properly escaped

Use bats (Bash Automated Testing System) format:
```bash
#!/usr/bin/env bats

@test "mcp_parse_request extracts fields from valid JSON-RPC" {
    result=$(mcp_parse_request '{"jsonrpc":"2.0","id":"123","method":"test","params":{"foo":"bar"}}')
    [ "$(echo "$result" | jq -r '.method')" = "test" ]
}
```

Make tests executable and add to test runner.
  </action>
  <verify>bats mcp-bridge/tests/test-mcp-core.bats 2>/dev/null || echo "bats not installed - manual verification needed"</verify>
  <done>Test file exists with comprehensive test cases covering all protocol functions</done>
</task>

</tasks>

<verification>
- mcp-errors.sh defines all 6 standard JSON-RPC error codes
- mcp-core.sh sources mcp-errors.sh and provides all required functions
- All JSON output uses jq (no shell string interpolation for JSON)
- Tests cover parse, result, response, and error scenarios
- No stdout pollution (all logging to stderr)
</verification>

<success_criteria>
1. mcp-bridge/lib/mcp-errors.sh exists with 6 error functions returning correct codes
2. mcp-bridge/lib/mcp-core.sh exists with parse, send_result, send_response functions
3. All functions produce valid JSON-RPC 2.0 messages
4. Test file exists with test coverage for all functions
5. Protocol version "2025-11-25" is used throughout
</success_criteria>

<output>
After completion, create `.planning/phases/08-mcp-bridge/08-01-SUMMARY.md`
</output>
