---
phase: 08-mcp-bridge
plan: 03
type: execute
wave: 3
depends_on:
  - 08-01
  - 08-02
files_modified:
  - mcp-bridge/lib/mcp-tools.sh
  - mcp-bridge/lib/file-reader.sh
autonomous: true

must_haves:
  truths:
    - "kimi_analyze tool accepts prompt, files, context, role and returns Kimi analysis"
    - "kimi_implement tool accepts prompt, files, constraints and returns implementation"
    - "kimi_refactor tool accepts prompt, files, safety_checks and returns refactored code"
    - "kimi_verify tool accepts prompt, files, requirements and returns verification result"
    - "All tools respect configuration defaults (model, timeout)"
    - "File contents are read and included in prompts when files array provided"
  artifacts:
    - path: "mcp-bridge/lib/file-reader.sh"
      provides: "Safe file reading with size limits"
      exports: ["mcp_read_files", "mcp_validate_file"]
    - path: "mcp-bridge/lib/mcp-tools.sh"
      provides: "Tool handler implementations for all 4 tools"
      exports: ["mcp_tool_analyze", "mcp_tool_implement", "mcp_tool_refactor", "mcp_tool_verify", "mcp_get_tool_definitions"]
  key_links:
    - from: "mcp-tools.sh"
      to: "file-reader.sh"
      via: "source"
      pattern: "source.*file-reader"
    - from: "mcp-tools.sh"
      to: "config.sh"
      via: "source"
      pattern: "source.*config"
    - from: "mcp-tools.sh"
      to: "mcp-core.sh"
      via: "source"
      pattern: "source.*mcp-core"
    - from: "mcp_tool_*"
      to: "kimi CLI"
      via: "timeout + kimi"
      pattern: "timeout.*kimi"
---

<objective>
Implement the 4 MCP tool handlers (kimi_analyze, kimi_implement, kimi_refactor, kimi_verify) plus file reading utilities with size limits.

Purpose: These are the actual tools exposed via MCP that clients will call to delegate work to Kimi.
Output: Tool handler library and file reading utilities.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/08-mcp-bridge/08-CONTEXT.md
@.planning/phases/08-mcp-bridge/08-RESEARCH.md

# Tool definitions from RESEARCH.md:
# - kimi_analyze: prompt (required), files (optional array), context (optional), role (optional, default "general")
# - kimi_implement: prompt (required), files (optional array), constraints (optional)
# - kimi_refactor: prompt (required), files (optional array), safety_checks (optional boolean, default true)
# - kimi_verify: prompt (required), files (optional array), requirements (optional)

# Tool result format from RESEARCH.md:
# {
#   "content": [{"type": "text", "text": "..."}],
#   "isError": false
# }

# File reading from CONTEXT.md:
# - Caller provides file paths, MCP server reads file contents
# - Max file size: 1MB default (configurable)
# - Include file path and content in prompt

# Implementation decisions from CONTEXT.md:
# - Synchronous only (no streaming)
# - Simple text output (not structured JSON)
# - Fail fast on errors
# - Include stderr in error messages
</context>

<tasks>

<task type="auto">
  <name>Create file-reader.sh with safe file reading</name>
  <files>mcp-bridge/lib/file-reader.sh</files>
  <action>
Create mcp-bridge/lib/file-reader.sh with safe file reading utilities.

Functions to implement:

1. mcp_validate_file(file_path, max_size)
   - Check if file exists and is readable
   - Check if file size is within limit
   - Return 0 if valid, 1 if invalid
   - Echo error message to stderr if invalid

2. mcp_read_file(file_path, max_size)
   - Read file content if valid
   - Return empty string with error message if invalid
   - Handle binary files gracefully (check with file command if available)

3. mcp_read_files(files_json, max_size)
   - Input: JSON array of file paths
   - Output: Formatted string with all file contents
   - Format:
     ```
     File: /path/to/file1
     [content]

     File: /path/to/file2
     [content]
     ```
   - Skip files that don't exist or exceed size limit
   - Log skipped files to stderr

4. mcp_format_file_content(file_path, content)
   - Format a single file for inclusion in prompt
   - Output: "File: [path]\n[content]\n"

Implementation details:
- Use stat to check file size (cross-platform: Linux uses stat -c%s, macOS uses stat -f%z)
- Detect platform and use appropriate stat flags
- Use cat to read files
- Handle spaces in file paths correctly
- Log all warnings to stderr

Example:
```bash
mcp_read_files() {
    local files_json="$1"
    local max_size="${2:-1048576}"
    local result=""
    
    local count=$(echo "$files_json" | jq 'length')
    for ((i=0; i<count; i++)); do
        local file_path=$(echo "$files_json" | jq -r ".[$i]")
        if mcp_validate_file "$file_path" "$max_size"; then
            local content=$(cat "$file_path")
            result="${result}File: ${file_path}\n${content}\n\n"
        fi
    done
    echo -e "$result"
}
```

Add header with file purpose and usage.
  </action>
  <verify>bash -c 'source mcp-bridge/lib/file-reader.sh && echo "test" > /tmp/testfile.txt && mcp_validate_file /tmp/testfile.txt 100 && echo "OK"'</verify>
  <done>File reader validates files, reads contents, and formats for prompt inclusion</done>
</task>

<task type="auto">
  <name>Create mcp-tools.sh with tool definitions and handlers</name>
  <files>mcp-bridge/lib/mcp-tools.sh</files>
  <action>
Create mcp-bridge/lib/mcp-tools.sh with all 4 tool handlers and tool definitions.

This file MUST source at the top:
- mcp-core.sh (for send_tool_result, send_tool_error)
- config.sh (for model, timeout, roles)
- file-reader.sh (for reading files)

Functions to implement:

1. mcp_get_tool_definitions()
   - Return JSON array of tool definitions per MCP spec
   - 4 tools: kimi_analyze, kimi_implement, kimi_refactor, kimi_verify
   - Each tool has: name, title, description, inputSchema
   - Use jq to generate valid JSON

2. mcp_tool_analyze(arguments_json)
   - Extract: prompt (required), files (optional array), context (optional), role (optional)
   - Build Kimi prompt:
     * Start with role system prompt from config (or "general")
     * Add file contents if files provided
     * Add context if provided
     * Add the main prompt
   - Call Kimi CLI with timeout
   - Return result via send_tool_result or send_tool_error

3. mcp_tool_implement(arguments_json)
   - Extract: prompt (required), files (optional array), constraints (optional)
   - Build Kimi prompt:
     * System: "You are an expert software developer. Implement the requested feature or fix."
     * Add file contents for context if provided
     * Add constraints if provided
     * Add the implementation request
   - Call Kimi CLI with timeout
   - Return result

4. mcp_tool_refactor(arguments_json)
   - Extract: prompt (required), files (optional array), safety_checks (optional, default true)
   - Build Kimi prompt:
     * System: "You are a refactoring expert. Improve code quality while preserving behavior."
     * If safety_checks=true, add: "Ensure all safety checks pass. Do not change behavior."
     * Add file contents
     * Add refactoring request
   - Call Kimi CLI with timeout
   - Return result

5. mcp_tool_verify(arguments_json)
   - Extract: prompt (required), files (optional array), requirements (optional)
   - Build Kimi prompt:
     * System: "You are a verification expert. Check if implementation meets requirements."
     * Add requirements if provided
     * Add file contents
     * Add verification criteria
   - Call Kimi CLI with timeout
   - Return result

Helper function:
6. mcp_call_kimi(prompt, model, timeout)
   - Call Kimi CLI: timeout ${timeout} kimi -m ${model} "${prompt}"
   - Capture stdout and stderr
   - Return exit code and output
   - Handle timeout (exit code 124) specially

Tool handler pattern:
```bash
mcp_tool_analyze() {
    local arguments="$1"
    local id="$2"
    
    # Extract parameters using jq
    local prompt=$(echo "$arguments" | jq -r '.prompt // empty')
    local files=$(echo "$arguments" | jq -r '.files // empty')
    local context=$(echo "$arguments" | jq -r '.context // empty')
    local role=$(echo "$arguments" | jq -r '.role // "general"')
    
    # Validate required parameter
    if [[ -z "$prompt" || "$prompt" == "null" ]]; then
        send_tool_error "$id" "Missing required parameter: prompt"
        return 1
    fi
    
    # Build full prompt
    local full_prompt=""
    
    # Add role system prompt
    local system_prompt=$(mcp_config_role "$role")
    full_prompt="${system_prompt}\n\n"
    
    # Add files if provided
    if [[ -n "$files" && "$files" != "null" && "$files" != "[]" ]]; then
        local max_size=$(mcp_config_max_file_size)
        local file_contents=$(mcp_read_files "$files" "$max_size")
        if [[ -n "$file_contents" ]]; then
            full_prompt="${full_prompt}Context files:\n${file_contents}\n"
        fi
    fi
    
    # Add context if provided
    if [[ -n "$context" && "$context" != "null" ]]; then
        full_prompt="${full_prompt}Additional context: ${context}\n\n"
    fi
    
    # Add main prompt
    full_prompt="${full_prompt}Task: ${prompt}"
    
    # Call Kimi
    local model=$(mcp_config_model)
    local timeout=$(mcp_config_timeout)
    local result exit_code
    
    result=$(mcp_call_kimi "$full_prompt" "$model" "$timeout")
    exit_code=$?
    
    if [[ $exit_code -eq 0 ]]; then
        send_tool_result "$id" "$result"
    else
        send_tool_error "$id" "Kimi CLI failed with exit code $exit_code: $result"
    fi
}
```

Critical requirements:
- Use jq for ALL JSON extraction
- Validate required parameters (prompt)
- Handle missing optional parameters gracefully
- Use config for model, timeout, max_file_size, roles
- Log to stderr, never stdout (except tool results via send_tool_result)
- Handle Kimi CLI errors and timeouts

Add header with file purpose and tool descriptions.
  </action>
  <verify>bash -c 'source mcp-bridge/lib/mcp-tools.sh && defs=$(mcp_get_tool_definitions) && echo "$defs" | jq -e ".tools | length == 4" && echo "OK"'</verify>
  <done>Tool definitions return 4 tools with valid JSON schemas, handlers extract params and build prompts</done>
</task>

<task type="auto">
  <name>Create tool handler tests</name>
  <files>mcp-bridge/tests/test-tools.bats</files>
  <action>
Create mcp-bridge/tests/test-tools.bats with tests for tool handlers.

Test cases:

1. mcp_get_tool_definitions
   - Returns valid JSON
   - Has exactly 4 tools
   - Each tool has name, title, description, inputSchema
   - kimi_analyze has role parameter with default
   - kimi_refactor has safety_checks parameter with default true

2. Parameter extraction
   - Valid JSON extracts correctly
   - Missing optional parameters default correctly
   - Missing required parameter (prompt) returns error

3. File reading integration
   - Files array is processed
   - Non-existent files are skipped with warning
   - Large files are skipped based on config

4. Prompt building
   - Role system prompt is included
   - File contents are formatted correctly
   - Context is added when provided

5. Tool-specific tests
   - kimi_analyze: uses role from config
   - kimi_implement: includes constraints
   - kimi_refactor: respects safety_checks flag
   - kimi_verify: includes requirements

Use mocking for Kimi CLI calls to avoid actual API usage in tests.

Example:
```bash
@test "tool definitions has 4 tools" {
    result=$(mcp_get_tool_definitions)
    count=$(echo "$result" | jq '.tools | length')
    [[ "$count" -eq 4 ]]
}

@test "kimi_analyze requires prompt parameter" {
    # Mock send_tool_error
    send_tool_error() { echo "ERROR: $2"; }
    result=$(mcp_tool_analyze '{}' '123')
    [[ "$result" == *"Missing required parameter"* ]]
}
```
  </action>
  <verify>bats mcp-bridge/tests/test-tools.bats 2>/dev/null || echo "bats not installed - manual verification needed"</verify>
  <done>Test file exists covering tool definitions, parameter validation, and prompt building</done>
</task>

</tasks>

<verification>
- file-reader.sh validates files and respects size limits
- mcp-tools.sh defines all 4 tools with correct schemas
- All tools validate required parameters
- Tools use configuration for defaults
- File contents are included in prompts when provided
- Kimi CLI is called with timeout and model from config
- Tests cover tool definitions and handler logic
</verification>

<success_criteria>
1. mcp-bridge/lib/file-reader.sh exists with validate and read functions
2. mcp-bridge/lib/mcp-tools.sh exists with 4 tool handlers
3. Tool definitions return valid MCP tool schemas
4. All handlers extract parameters using jq
5. File reading respects size limits and skips invalid files
6. Prompts include system roles, file contents, and context
7. Tests verify tool definitions and parameter handling
</success_criteria>

<output>
After completion, create `.planning/phases/08-mcp-bridge/08-03-SUMMARY.md`
</output>
