---
phase: 08-mcp-bridge
plan: 02
type: execute
wave: 2
depends_on: []
files_modified:
  - mcp-bridge/lib/config.sh
  - mcp-bridge/config/default.json
autonomous: true

must_haves:
  truths:
    - "MCP server loads configuration from ~/.config/kimi-mcp/config.json"
    - "Environment variables KIMI_MCP_* override config file values"
    - "Configuration provides default model (k2) and timeout (30s)"
  artifacts:
    - path: "mcp-bridge/lib/config.sh"
      provides: "Configuration loading and access functions"
      exports: ["mcp_config_load", "mcp_config_get", "mcp_config_model", "mcp_config_timeout"]
    - path: "mcp-bridge/config/default.json"
      provides: "Default configuration values"
      contains: ["model", "timeout", "max_file_size"]
  key_links:
    - from: "config.sh"
      to: "~/.config/kimi-mcp/config.json"
      via: "file read"
      pattern: "jq -r.*config.json"
    - from: "environment"
      to: "config.sh"
      via: "env var"
      pattern: "KIMI_MCP_MODEL|KIMI_MCP_TIMEOUT"
---

<objective>
Implement configuration management for the MCP server: loading from config file, environment variable overrides, and default values.

Purpose: Tools need configurable defaults (model selection, timeout) that can be set globally and overridden per-environment.
Output: Configuration library and default config file.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/08-mcp-bridge/08-CONTEXT.md
@.planning/phases/08-mcp-bridge/08-RESEARCH.md

# Configuration requirements from CONTEXT.md:
# - Config file: ~/.config/kimi-mcp/config.json
# - Env var prefix: KIMI_MCP_*
# - Configurable: model (k2 vs k2.5), timeout (seconds)
# - Defaults: K2 model, 30 second timeout
# - Precedence: env vars > config file > defaults

# From RESEARCH.md Pattern 3: Configuration Hierarchy
# load_config() {
#     local config_file="${HOME}/.config/kimi-mcp/config.json"
#     MODEL="${KIMI_MCP_MODEL:-k2}"
#     TIMEOUT="${KIMI_MCP_TIMEOUT:-30}"
#     if [[ -f "$config_file" ]]; then
#         local file_model=$(jq -r '.model // empty' "$config_file")
#         [[ -n "$file_model" ]] && MODEL="$file_model"
#     fi
#     MODEL="${KIMI_MCP_MODEL:-$MODEL}"
# }
</context>

<tasks>

<task type="auto">
  <name>Create default configuration file</name>
  <files>mcp-bridge/config/default.json</files>
  <action>
Create mcp-bridge/config/default.json with default configuration values.

Required fields:
{
  "model": "k2",
  "timeout": 30,
  "max_file_size": 1048576,
  "roles": {
    "general": "You are a helpful coding assistant.",
    "security": "You are a security-focused code reviewer. Analyze for vulnerabilities, injection risks, and security best practices.",
    "performance": "You are a performance optimization expert. Analyze for efficiency, bottlenecks, and optimization opportunities.",
    "refactor": "You are a refactoring expert. Suggest clean, maintainable code improvements while preserving behavior."
  }
}

Fields:
- model: Default Kimi model to use ("k2" or "k2.5")
- timeout: Default timeout in seconds for Kimi CLI calls (integer)
- max_file_size: Maximum file size in bytes to read (1MB default)
- roles: System prompts for different analysis roles

Ensure valid JSON with proper formatting. Use jq to validate after creation.
  </action>
  <verify>jq empty mcp-bridge/config/default.json && jq -e ".model == \"k2\" and .timeout == 30" mcp-bridge/config/default.json</verify>
  <done>Default config file exists with valid JSON containing all required fields</done>
</task>

<task type="auto">
  <name>Create config.sh library</name>
  <files>mcp-bridge/lib/config.sh</files>
  <action>
Create mcp-bridge/lib/config.sh with configuration loading and access functions.

Configuration precedence (highest to lowest):
1. Environment variables (KIMI_MCP_MODEL, KIMI_MCP_TIMEOUT, etc.)
2. User config file (~/.config/kimi-mcp/config.json)
3. Default config file (mcp-bridge/config/default.json)

Functions to implement:

1. mcp_config_load()
   - Load configuration from all sources into global variables
   - Set MCP_CONFIG_MODEL, MCP_CONFIG_TIMEOUT, MCP_CONFIG_MAX_FILE_SIZE
   - Set MCP_CONFIG_ROLES (as JSON string)
   - Log loading status to stderr (which file loaded, any errors)
   - Handle missing files gracefully (use defaults)

2. mcp_config_get(key)
   - Get a configuration value by key
   - Keys: "model", "timeout", "max_file_size"
   - Echo the value

3. mcp_config_model()
   - Echo the current model setting (k2 or k2.5)

4. mcp_config_timeout()
   - Echo the current timeout in seconds

5. mcp_config_max_file_size()
   - Echo the max file size in bytes

6. mcp_config_role(role_name)
   - Get system prompt for a role
   - Input: role name (general, security, performance, refactor)
   - Output: system prompt string
   - Falls back to "general" if role not found

Implementation notes:
- Config file path: "${HOME}/.config/kimi-mcp/config.json"
- Create config directory if it doesn't exist
- Use jq for all JSON reading
- Validate model values (only accept "k2" or "k2.5")
- Ensure timeout is a positive integer
- Log all activity to stderr

Example loading logic:
```bash
mcp_config_load() {
    local user_config="${HOME}/.config/kimi-mcp/config.json"
    local default_config="${MCP_BRIDGE_ROOT}/config/default.json"
    
    # Start with defaults
    MCP_CONFIG_MODEL=$(jq -r '.model // "k2"' "$default_config")
    MCP_CONFIG_TIMEOUT=$(jq -r '.timeout // 30' "$default_config")
    
    # Override with user config if exists
    if [[ -f "$user_config" ]]; then
        local user_model=$(jq -r '.model // empty' "$user_config")
        [[ -n "$user_model" ]] && MCP_CONFIG_MODEL="$user_model"
    fi
    
    # Override with environment
    MCP_CONFIG_MODEL="${KIMI_MCP_MODEL:-$MCP_CONFIG_MODEL}"
    MCP_CONFIG_TIMEOUT="${KIMI_MCP_TIMEOUT:-$MCP_CONFIG_TIMEOUT}"
}
```

Add header with file purpose and usage examples.
  </action>
  <verify>bash -c 'MCP_BRIDGE_ROOT="./mcp-bridge" source mcp-bridge/lib/config.sh && mcp_config_load && [[ "$(mcp_config_model)" == "k2" ]] && echo "OK"'</verify>
  <done>Config library loads defaults correctly and provides access functions</done>
</task>

<task type="auto">
  <name>Create configuration tests</name>
  <files>mcp-bridge/tests/test-config.bats</files>
  <action>
Create mcp-bridge/tests/test-config.bats with tests for configuration functions.

Test cases:

1. mcp_config_load with defaults only
   - No user config file exists
   - No env vars set
   - Should load values from default.json

2. mcp_config_load with user config override
   - Create temp config file with different values
   - Should use user config values over defaults

3. mcp_config_load with env var override
   - Set KIMI_MCP_MODEL=k2.5
   - Should use env var over file values

4. mcp_config_load precedence
   - Set env var AND user config
   - Env var should win

5. mcp_config_get for each key
   - Test model, timeout, max_file_size

6. mcp_config_role
   - Test each built-in role
   - Test unknown role falls back to general

7. Missing config file handling
   - Should not error, use defaults

Use setup() and teardown() for temp files.

Example:
```bash
#!/usr/bin/env bats

setup() {
    export MCP_BRIDGE_ROOT="${BATS_TEST_DIRNAME}/.."
    source "${MCP_BRIDGE_ROOT}/lib/config.sh"
}

@test "config loads defaults when no user config exists" {
    [[ ! -f "${HOME}/.config/kimi-mcp/config.json" ]]
    mcp_config_load
    [[ "$MCP_CONFIG_MODEL" == "k2" ]]
    [[ "$MCP_CONFIG_TIMEOUT" == "30" ]]
}
```
  </action>
  <verify>bats mcp-bridge/tests/test-config.bats 2>/dev/null || echo "bats not installed - manual verification needed"</verify>
  <done>Test file exists covering defaults, file loading, env vars, and precedence</done>
</task>

</tasks>

<verification>
- default.json has valid JSON with all required fields
- config.sh loads from defaults, user config, and env vars in correct precedence
- All config access functions work correctly
- Tests verify precedence and error handling
- Config directory creation is handled
</verification>

<success_criteria>
1. mcp-bridge/config/default.json exists with valid JSON
2. mcp-bridge/lib/config.sh provides load and get functions
3. Configuration precedence works: env > user config > defaults
4. All settings have sensible defaults (k2, 30s, 1MB)
5. Role system prompts are defined
6. Tests cover configuration loading scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/08-mcp-bridge/08-02-SUMMARY.md`
</output>
