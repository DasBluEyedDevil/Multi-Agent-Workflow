---
phase: 08-mcp-bridge
plan: 04
type: execute
wave: 4
depends_on:
  - 08-01
  - 08-02
  - 08-03
files_modified:
  - mcp-bridge/bin/kimi-mcp-server
  - mcp-bridge/tests/test-server.bats
autonomous: true

must_haves:
  truths:
    - "MCP server executable starts and enters JSON-RPC message loop"
    - "Server handles initialize method and returns InitializeResult"
    - "Server handles tools/list method and returns tool definitions"
    - "Server handles tools/call method and dispatches to correct tool handler"
    - "Server handles unknown methods with Method Not Found error"
    - "Server shuts down cleanly when stdin closes"
  artifacts:
    - path: "mcp-bridge/bin/kimi-mcp-server"
      provides: "Main MCP server executable"
      exports: ["main message loop", "signal handlers"]
    - path: "mcp-bridge/tests/test-server.bats"
      provides: "Integration tests for server"
  key_links:
    - from: "kimi-mcp-server"
      to: "mcp-core.sh"
      via: "source"
      pattern: "source.*mcp-core"
    - from: "kimi-mcp-server"
      to: "mcp-tools.sh"
      via: "source"
      pattern: "source.*mcp-tools"
    - from: "kimi-mcp-server"
      to: "config.sh"
      via: "source"
      pattern: "source.*config"
    - from: "message loop"
      to: "tool handlers"
      via: "dispatch"
      pattern: "mcp_tool_"
---

<objective>
Create the main MCP server executable that ties together all components: message loop, method dispatch, and lifecycle management.

Purpose: This is the entry point that MCP clients will execute. It implements the full MCP server lifecycle.
Output: Executable server script and integration tests.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/08-mcp-bridge/08-CONTEXT.md
@.planning/phases/08-mcp-bridge/08-RESEARCH.md

# MCP Server Lifecycle from RESEARCH.md:
# 1. INITIALIZATION: Client sends "initialize" -> Server returns InitializeResult
# 2. OPERATION: Client sends "tools/list" or "tools/call" -> Server responds
# 3. SHUTDOWN: Client closes stdin -> Server exits

# Main message loop pattern from RESEARCH.md:
# while IFS= read -r line; do
#     method=$(echo "$line" | jq -r '.method // empty')
#     id=$(echo "$line" | jq -r '.id // empty')
#     params=$(echo "$line" | jq -r '.params // {}')
#     case "$method" in
#         "initialize") handle_initialize "$id" "$params" ;;
#         "tools/list") handle_tools_list "$id" ;;
#         "tools/call") handle_tools_call "$id" "$params" ;;
#         *) send_error "$id" -32601 "Method not found" ;;
#     esac
# done

# Critical from CONTEXT.md:
# - stdio transport only
# - No authentication
# - Fail fast on errors
# - Single connection, serialize requests
</context>

<tasks>

<task type="auto">
  <name>Create main MCP server executable</name>
  <files>mcp-bridge/bin/kimi-mcp-server</files>
  <action>
Create mcp-bridge/bin/kimi-mcp-server as the main MCP server executable.

Shebang: #!/usr/bin/env bash

The script must:

1. Set up environment
   - Determine script location and set MCP_BRIDGE_ROOT
   - Source all required libraries:
     * mcp-core.sh
     * mcp-errors.sh
     * mcp-tools.sh
     * config.sh
     * file-reader.sh
   - Load configuration via mcp_config_load
   - Log startup to stderr

2. Set up signal handlers
   - Trap SIGINT and SIGTERM for clean shutdown
   - Log shutdown to stderr

3. Implement method handlers

   handle_initialize(id, params):
   - Extract client protocolVersion from params
   - Return InitializeResult with:
     * protocolVersion: "2025-11-25"
     * capabilities: {tools: {listChanged: false}}
     * serverInfo: {name: "kimi-mcp-server", version: "1.0.0"}
   - Use mcp_send_initialize_result

   handle_tools_list(id):
   - Return tool definitions via mcp_get_tool_definitions
   - Use mcp_send_tools_list

   handle_tools_call(id, params):
   - Extract tool name from params: echo "$params" | jq -r '.name'
   - Extract arguments: echo "$params" | jq -r '.arguments // {}'
   - Dispatch to appropriate handler:
     * "kimi_analyze" -> mcp_tool_analyze "$arguments" "$id"
     * "kimi_implement" -> mcp_tool_implement "$arguments" "$id"
     * "kimi_refactor" -> mcp_tool_refactor "$arguments" "$id"
     * "kimi_verify" -> mcp_tool_verify "$arguments" "$id"
   - Unknown tool: send_tool_error "$id" "Unknown tool: [name]"

4. Main message loop
   ```bash
   log_info "Kimi MCP Server starting..."
   
   while IFS= read -r line; do
       # Skip empty lines
       [[ -z "$line" ]] && continue
       
       # Validate JSON
       if ! echo "$line" | jq empty 2>/dev/null; then
           send_error "" -32700 "Parse error: Invalid JSON"
           continue
       fi
       
       # Extract fields
       local id=$(echo "$line" | jq -r '.id // empty')
       local method=$(echo "$line" | jq -r '.method // empty')
       local params=$(echo "$line" | jq -r '.params // {}')
       
       # Validate JSON-RPC
       if [[ -z "$method" ]]; then
           send_error "$id" -32600 "Invalid Request: missing method"
           continue
       fi
       
       # Dispatch
       case "$method" in
           "initialize")
               handle_initialize "$id" "$params"
               ;;
           "tools/list")
               handle_tools_list "$id"
               ;;
           "tools/call")
               handle_tools_call "$id" "$params"
               ;;
           "notifications/initialized")
               # Notification, no response needed
               ;;
           *)
               send_error "$id" -32601 "Method not found: $method"
               ;;
       esac
   done
   
   log_info "Kimi MCP Server shutting down..."
   ```

5. Helper functions
   - log_info(msg): Echo to stderr with "[INFO]" prefix
   - log_error(msg): Echo to stderr with "[ERROR]" prefix

Critical requirements:
- ALL output to stdout MUST be valid JSON-RPC
- ALL logging MUST go to stderr
- Handle JSON parse errors gracefully
- Preserve request IDs in responses
- Exit cleanly when stdin closes

Make executable: chmod +x mcp-bridge/bin/kimi-mcp-server
  </action>
  <verify>chmod +x mcp-bridge/bin/kimi-mcp-server && test -x mcp-bridge/bin/kimi-mcp-server && echo "OK"</verify>
  <done>Server executable exists, is executable, and contains main message loop with all method handlers</done>
</task>

<task type="auto">
  <name>Create integration tests for server</name>
  <files>mcp-bridge/tests/test-server.bats</files>
  <action>
Create mcp-bridge/tests/test-server.bats with integration tests for the MCP server.

Test cases:

1. Server startup
   - Server starts without errors
   - Logs startup message to stderr

2. Initialize handshake
   - Send initialize request
   - Receive valid InitializeResult
   - Correct protocol version (2025-11-25)
   - Correct server info

3. Tools list
   - Send tools/list request
   - Receive 4 tool definitions
   - Each tool has required fields

4. Tool call - analyze
   - Send tools/call for kimi_analyze
   - Tool executes and returns result
   - Result has correct MCP format

5. Tool call - unknown tool
   - Send tools/call for unknown tool
   - Receive tool error (not protocol error)
   - Error message mentions unknown tool

6. Method not found
   - Send request with unknown method
   - Receive JSON-RPC error -32601

7. Invalid JSON
   - Send invalid JSON
   - Receive JSON-RPC error -32700

8. Invalid request (missing method)
   - Send JSON without method field
   - Receive JSON-RPC error -32600

9. Shutdown
   - Close stdin
   - Server exits cleanly

Test helper functions:
```bash
send_request() {
    local method="$1"
    local params="${2:-{}}"
    local id="${3:-1}"
    jq -n --arg method "$method" --argjson params "$params" --arg id "$id" \
        '{jsonrpc: "2.0", id: $id, method: $method, params: $params}'
}

@test "server responds to initialize" {
    request=$(send_request "initialize" '{"protocolVersion": "2025-11-25"}')
    response=$(echo "$request" | "${MCP_BRIDGE_ROOT}/bin/kimi-mcp-server" 2>/dev/null)
    echo "$response" | jq -e '.result.protocolVersion == "2025-11-25"'
}
```

Note: Some tests may need to mock kimi CLI to avoid actual API calls.
  </action>
  <verify>bats mcp-bridge/tests/test-server.bats 2>/dev/null || echo "bats not installed - manual verification needed"</verify>
  <done>Integration tests exist covering initialize, tools/list, tools/call, and error handling</done>
</task>

<task type="auto">
  <name>Create test runner script</name>
  <files>mcp-bridge/tests/run-tests.sh</files>
  <action>
Create mcp-bridge/tests/run-tests.sh to run all tests.

The script should:
1. Detect if bats is installed
2. If bats available: run all .bats files
3. If bats not available: print manual test instructions
4. Report pass/fail counts
5. Exit with non-zero if any tests fail

Structure:
```bash
#!/usr/bin/env bash
set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
MCP_BRIDGE_ROOT="$(dirname "$SCRIPT_DIR")"

echo "Running Kimi MCP Server tests..."
echo "================================"

if ! command -v bats &> /dev/null; then
    echo "WARNING: bats not installed. Manual testing required."
    echo ""
    echo "Manual test checklist:"
    echo "1. Test server startup: echo '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"initialize\",\"params\":{}}' | ./bin/kimi-mcp-server"
    echo "2. Test tools/list: echo '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/list\"}' | ./bin/kimi-mcp-server"
    echo ""
    exit 0
fi

# Run all test files
failed=0
for test_file in "$SCRIPT_DIR"/*.bats; do
    echo "Running: $(basename "$test_file")"
    if ! bats "$test_file"; then
        failed=1
    fi
done

if [[ $failed -eq 0 ]]; then
    echo ""
    echo "All tests passed!"
    exit 0
else
    echo ""
    echo "Some tests failed!"
    exit 1
fi
```

Make executable.
  </action>
  <verify>chmod +x mcp-bridge/tests/run-tests.sh && test -x mcp-bridge/tests/run-tests.sh && echo "OK"</verify>
  <done>Test runner script exists and is executable</done>
</task>

</tasks>

<verification>
- Server executable is created and executable
- All required libraries are sourced
- Main message loop reads from stdin and dispatches correctly
- Initialize returns correct protocol version and capabilities
- Tools/list returns all 4 tool definitions
- Tools/call dispatches to correct handler
- Unknown methods return Method Not Found error
- Invalid JSON returns Parse error
- Server logs to stderr only
- Integration tests cover all methods
- Test runner script exists
</verification>

<success_criteria>
1. mcp-bridge/bin/kimi-mcp-server exists and is executable
2. Server implements initialize, tools/list, tools/call handlers
3. Server returns correct MCP protocol version (2025-11-25)
4. Server dispatches tool calls to correct handlers
5. Error handling follows JSON-RPC spec
6. Integration tests exist for all server methods
7. Test runner script executes all tests
</success_criteria>

<output>
After completion, create `.planning/phases/08-mcp-bridge/08-04-SUMMARY.md`
</output>
